// Generated by CoffeeScript 1.3.1
var SCALE_FACTOR, app, log;

log = function(obj) {
  try {
    return console.log(obj);
  } catch (_error) {}
};

SCALE_FACTOR = 2;

app = {
  width: 800,
  height: 800,
  x: 0,
  y: 0,
  scale: 1,
  objects: [],
  object_id: 1,
  canvas: false,
  drawguideline: true,
  is_moving: false,
  is_scaling: false,
  is_rotating: false,
  bgimg: null,
  bgimg_width: null,
  bgimg_height: null,
  options: {},
  init: function(options) {
    var canvas, default_options,
      _this = this;
    default_options = {
      canvas: 'canvas',
      canvas_width: 800,
      canvas_height: 600,
      max_width: 10000,
      max_height: 10000,
      bgurl: null,
      bgopacity: 1,
      bgscale: 1
    };
    this.options = $.extend(default_options, options);
    this.x = this.options.max_width / 2 - this.options.canvas_width;
    this.y = this.options.max_height / 2 - this.options.canvas_width;
    canvas = new fabric.Canvas(this.options.canvas);
    canvas.setWidth(this.options.canvas_width);
    canvas.setHeight(this.options.canvas_height);
    initAligningGuidelines(canvas);
    this.canvas = canvas;
    if (this.options.bgurl) {
      fabric.Image.fromURL(this.options.bgurl, function(img) {
        _this.bgimg = img;
        _this.bgimg_width = img.width;
        return _this.bgimg_height = img.height;
      });
    }
    this.canvas.on('object:selected', function(e) {
      var object;
      return object = e.target;
    });
    this.canvas.on('object:modified', function(e) {
      var object;
      object = e.target;
      log('modified');
      if (_this.is_moving) {
        _this.moving(object);
      }
      if (_this.is_scaling) {
        _this.scaling(object);
      }
      if (_this.is_rotating) {
        _this.rotating(object);
      }
      _this.is_moving = false;
      _this.is_scaling = false;
      return _this.is_rotating = false;
    });
    this.canvas.on('object:moving', function(e) {
      var object;
      object = e.target;
      log('moving');
      return _this.is_moving = true;
    });
    this.canvas.on('object:scaling', function(e) {
      var object;
      object = e.target;
      log('scaling');
      return _this.is_scaling = true;
    });
    return this.canvas.on('object:rotating', function(e) {
      var object;
      object = e.target;
      log('rotating');
      return _this.is_rotating = true;
    });
  },
  add: function(object) {
    var o, prop, props, _i, _len;
    object.__id = this.object_id;
    this.object_id += 1;
    o = {
      object: object
    };
    props = 'width height scaleX scaleY left top angle fill stroke'.split(' ');
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      o[prop] = object[prop];
    }
    this.objects.push(o);
    return o;
  },
  bind: function(func, unselect) {
    var group, object, objects, _i, _len;
    if (unselect == null) {
      unselect = true;
    }
    object = this.canvas.getActiveObject();
    if (object) {
      return func(object);
    }
    group = this.canvas.getActiveGroup();
    if (group) {
      objects = group._objects;
      if (unselect) {
        this.canvas.deactivateAll().renderAll();
      }
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i];
        func(object);
      }
    }
    return this.render();
  },
  remove: function() {
    var _this = this;
    return this.bind(function(object) {
      var count;
      _this.canvas.remove(object);
      count = _this.match(object);
      if (count !== null) {
        return _this.objects.splice(count, 1);
      }
    });
  },
  bringToFront: function() {
    var _this = this;
    return this.bind(function(object) {
      var count, obj;
      count = _this.match(object);
      if (count !== null) {
        object.bringToFront();
        obj = _this.objects[count];
        _this.objects.splice(count, 1);
        return _this.objects.push(obj);
      }
    });
  },
  match: function(object) {
    var count, o, _i, _len, _ref;
    count = 0;
    _ref = this.objects;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      o = _ref[_i];
      if (o['object'].__id === object.__id) {
        return count;
      }
      count += 1;
    }
    return null;
  },
  moving: function(object) {
    var _this = this;
    log('moving');
    return this.bind(function(object) {
      var count;
      count = _this.match(object);
      if (count !== null) {
        _this.objects[count].top = object.top / _this.scale + app.y;
        return _this.objects[count].left = object.left / _this.scale + app.x;
      }
    });
  },
  scaling: function(object) {
    var _this = this;
    log('scaling');
    return this.bind(function(object) {
      var count;
      log(object);
      count = _this.match(object);
      if (count !== null) {
        log(object.scaleX);
        _this.objects[count].scaleX = object.scaleX / _this.scale;
        _this.objects[count].scaleY = object.scaleY / _this.scale;
        _this.objects[count].top = object.top / _this.scale + app.y;
        return _this.objects[count].left = object.left / _this.scale + app.x;
      }
    });
  },
  rotating: function(object) {
    var _this = this;
    log('rotating');
    return this.bind(function(object) {
      var count;
      count = _this.match(object);
      if (count !== null) {
        _this.objects[count].angle = object.angle;
        _this.objects[count].top = object.top / _this.scale + app.y;
        return _this.objects[count].left = object.left / _this.scale + app.x;
      }
    });
  },
  render: function() {
    var angle, left, o, object, scaleX, scaleY, tempLeft, tempScaleX, tempScaleY, tempTop, top;
    if (this.objects.length <= 0) {
      return;
    }
    this.canvas.clear();
    for (o in this.objects) {
      scaleX = this.objects[o].scaleX;
      scaleY = this.objects[o].scaleY;
      left = this.objects[o].left;
      top = this.objects[o].top;
      angle = this.objects[o].angle;
      tempScaleX = scaleX * this.scale;
      tempScaleY = scaleY * this.scale;
      tempLeft = left * this.scale - app.x * this.scale;
      tempTop = top * this.scale - app.y * this.scale;
      object = this.objects[o]['object'];
      object.scaleX = tempScaleX;
      object.scaleY = tempScaleY;
      object.left = tempLeft;
      object.top = tempTop;
      if (angle > 0) {
        object.angle = angle;
      }
      object.originX = 'center';
      object.originY = 'center';
      object.setCoords();
      this.canvas.add(object);
    }
    if (this.scale === 1 && this.drawguideline) {
      fabric.drawGridLines(this.canvas);
    }
    this.canvas.renderAll();
    if (this.bgimg) {
      this.bgimg.left = -(this.x * this.scale);
      this.bgimg.top = -(this.y * this.scale);
      this.bgimg.width = this.bgimg_width * this.options.bgscale * this.scale;
      this.bgimg.height = this.bgimg_height * this.options.bgscale * this.scale;
      this.bgimg.opacity = this.options.bgopacity;
      return this.canvas.setBackgroundImage(this.bgimg, this.canvas.renderAll.bind(this.canvas));
    }
  },
  zoomIn: function() {
    var x, y;
    this.scale += 0.1;
    this.scale = (this.scale * 100).toFixed(0) / 100;
    x = this.x + this.canvas.getWidth() / 2;
    y = this.y + this.canvas.getHeight() / 2;
    this.x = x - (this.canvas.getWidth() * this.scale / 2);
    this.y = y - (this.canvas.getHeight() * this.scale / 2);
    this.render();
    return $('.zoom').html((this.scale * 100).toFixed(0) + '%');
  },
  zoomOut: function() {
    var x, y;
    if (this.scale <= 0.1) {
      return;
    }
    this.scale -= 0.1;
    this.scale = (this.scale * 100).toFixed(0) / 100;
    x = this.x + this.canvas.getWidth() / 2;
    y = this.y + this.canvas.getHeight() / 2;
    this.x = x - (this.canvas.getWidth() * this.scale / 2);
    this.y = y - (this.canvas.getHeight() * this.scale / 2);
    if (this.x < 0) {
      this.x = 0;
    }
    if (this.y < 0) {
      this.y = 0;
    }
    this.render();
    return $('.zoom').html((this.scale * 100).toFixed(0) + '%');
  },
  zoomReset: function() {
    this.scale = 1;
    this.render();
    return $('.zoom').html('100%');
  },
  toTop: function(y) {
    if (y == null) {
      y = 100;
    }
    if (this.y > 0) {
      this.y -= y;
      return this.render();
    }
  },
  toBottom: function(y) {
    if (y == null) {
      y = 100;
    }
    this.y += y;
    return this.render();
  },
  toRight: function(x) {
    if (x == null) {
      x = 100;
    }
    this.x += x;
    return this.render();
  },
  toLeft: function(x) {
    if (x == null) {
      x = 100;
    }
    if (this.x > 0) {
      this.x -= x;
      return this.render();
    }
  },
  save: function() {
    var a, blob, canvas, svg, tmp_canvas;
    canvas = document.createElement('canvas');
    canvas = new fabric.Canvas(canvas);
    canvas.setWidth(this.options.max_width);
    canvas.setHeight(this.options.max_height);
    tmp_canvas = this.canvas;
    this.canvas = canvas;
    this.drawguideline = false;
    this.render();
    this.drawguideline = true;
    svg = this.canvas.toSVG();
    this.canvas = tmp_canvas;
    a = document.createElement('a');
    a.download = 'sample.svg';
    a.type = 'image/svg+xml';
    blob = new Blob([svg], {
      "type": "image/svg+xml"
    });
    a.href = (window.URL || webkitURL).createObjectURL(blob);
    return a.click();
  }
};
