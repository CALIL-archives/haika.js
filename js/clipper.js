// Generated by CoffeeScript 1.7.1
var clip_paths, coordinates, geojson, geometry, log, merge, new_paths, object, p, path, paths, paths2string, scale, solution_paths, subj_paths, svg, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;

log = function(obj) {
  try {
    return console.log(obj);
  } catch (_error) {}
};

merge = function(paths) {
  var cpr, path, solution_paths, succeeded, _i, _len;
  cpr = new ClipperLib.Clipper();
  ClipperLib.JS.ScaleUpPaths(subj_paths, scale);
  ClipperLib.JS.ScaleUpPaths(clip_paths, scale);
  ClipperLib.JS.ScaleUpPaths(new_paths, scale);
  for (_i = 0, _len = paths.length; _i < _len; _i++) {
    path = paths[_i];
    cpr.AddPaths(path, ClipperLib.PolyType.ptSubject, true);
  }
  solution_paths = new ClipperLib.Paths();
  succeeded = cpr.Execute(ClipperLib.ClipType.ctUnion, solution_paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
  return solution_paths;
};

paths2string = function(paths, scale) {
  var i, j, svgpath;
  svgpath = "";
  i = void 0;
  j = void 0;
  if (!scale) {
    scale = 1;
  }
  i = 0;
  while (i < paths.length) {
    j = 0;
    while (j < paths[i].length) {
      if (!j) {
        svgpath += "M";
      } else {
        svgpath += "L";
      }
      svgpath += (paths[i][j].X / scale) + ", " + (paths[i][j].Y / scale);
      j++;
    }
    svgpath += "Z";
    i++;
  }
  if (svgpath === "") {
    svgpath = "M0,0";
  }
  return svgpath;
};

subj_paths = [
  [
    {
      X: 10,
      Y: 10
    }, {
      X: 110,
      Y: 10
    }, {
      X: 110,
      Y: 110
    }, {
      X: 10,
      Y: 110
    }
  ]
];

clip_paths = [
  [
    {
      X: 50,
      Y: 50
    }, {
      X: 150,
      Y: 50
    }, {
      X: 150,
      Y: 150
    }, {
      X: 50,
      Y: 150
    }
  ]
];

new_paths = [
  [
    {
      X: 0,
      Y: 150
    }, {
      X: 150,
      Y: 150
    }, {
      X: 150,
      Y: 250
    }, {
      X: 0,
      Y: 250
    }
  ]
];

scale = 100;

geojson = JSON.parse(localStorage.getItem('geojson'));

log(geojson);

paths = [];

if (geojson && geojson.features.length > 0) {
  _ref = geojson.features;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    object = _ref[_i];
    if (object.properties.type === 'floor') {
      path = [];
      log(object.geometry.coordinates[0]);
      _ref1 = object.geometry.coordinates[0];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        geometry = _ref1[_j];
        p = {
          X: geometry[0] * 1000 + 4500,
          Y: geometry[1] * 1000 + 4500
        };
        path.push(p);
      }
      paths.push([path]);
    }
  }
}

log(paths);

log(subj_paths);

solution_paths = merge(paths);

console.log(JSON.stringify(solution_paths));

coordinates = [];

_ref2 = solution_paths[0];
for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
  path = _ref2[_k];
  coordinates.push([path.X, path.Y]);
}

log(coordinates);

svg = "<svg style=\"background-color:#dddddd\" width=\"1600\" height=\"1600\">";

svg += "<path stroke=\"black\" fill=\"yellow\" stroke-width=\"2\" d=\"" + paths2string(solution_paths, scale) + "\"/>";

svg += "</svg>";

document.getElementById("svgcontainer").innerHTML = svg;

paths = [
  [
    {
      X: 10,
      Y: 10
    }, {
      X: 110,
      Y: 10
    }, {
      X: 110,
      Y: 110
    }, {
      X: 10,
      Y: 110
    }
  ]
];

console.log(JSON.stringify(paths));

ClipperLib.Clipper.ReversePaths(paths);

console.log(JSON.stringify(paths));

/*
//@ sourceMappingURL=clipper.map
*/
