初期設計

キャンバスの大きさ

width
height

現在の座標

x
y

倍率

zoom


オブジェクト

objects

width
height
top
left
scaleX
scaleY

オブジェクトの追加
object:added

オブジェクトの削除
object:removed

オブジェクトの移動
object:moving

オブジェクトの拡大縮小
object:scaling

オブジェクトの回転
object:rotating

書き換え
after:render


obj.on({
        moving: setCoords,
        scaling: setCoords,
        rotating: setCoords
      });


# Zoom In
app.zoomIn = ->
  
  # TODO limit the max canvas zoom in
  canvasScale = canvasScale * SCALE_FACTOR
  objects = canvas.getObjects()
  for i of objects
    scaleX = objects[i].scaleX
    scaleY = objects[i].scaleY
    left = objects[i].left
    top = objects[i].top
    tempScaleX = scaleX * SCALE_FACTOR
    tempScaleY = scaleY * SCALE_FACTOR
    tempLeft = left * SCALE_FACTOR
    tempTop = top * SCALE_FACTOR
    objects[i].scaleX = tempScaleX
    objects[i].scaleY = tempScaleY
    objects[i].left = tempLeft
    objects[i].top = tempTop
    objects[i].setCoords()
  width = canvas.getWidth()
  height = canvas.getHeight()
  tempWidth = width * SCALE_FACTOR
  tempHeight = height * SCALE_FACTOR
  canvas.setWidth tempWidth
  canvas.setHeight tempHeight
  canvas.renderAll()
  return


# Zoom Out
app.zoomOut = ->
  
  # TODO limit max cavas zoom out
  canvasScale = canvasScale / SCALE_FACTOR
  objects = canvas.getObjects()
  for i of objects
    scaleX = objects[i].scaleX
    scaleY = objects[i].scaleY
    left = objects[i].left
    top = objects[i].top
    tempScaleX = scaleX * (1 / SCALE_FACTOR)
    tempScaleY = scaleY * (1 / SCALE_FACTOR)
    tempLeft = left * (1 / SCALE_FACTOR)
    tempTop = top * (1 / SCALE_FACTOR)
    objects[i].scaleX = tempScaleX
    objects[i].scaleY = tempScaleY
    objects[i].left = tempLeft
    objects[i].top = tempTop
    objects[i].setCoords()
  width = canvas.getWidth()
  height = canvas.getHeight()
  tempWidth = width * (1 / SCALE_FACTOR)
  tempHeight = height * (1 / SCALE_FACTOR)
  canvas.setWidth tempWidth
  canvas.setHeight tempHeight
  canvas.renderAll()
  return

# Reset Zoom
app.resetZoom = ->
  objects = canvas.getObjects()
  for i of objects
    scaleX = objects[i].scaleX
    scaleY = objects[i].scaleY
    left = objects[i].left
    top = objects[i].top
    tempScaleX = scaleX * (1 / canvasScale)
    tempScaleY = scaleY * (1 / canvasScale)
    tempLeft = left * (1 / canvasScale)
    tempTop = top * (1 / canvasScale)
    objects[i].scaleX = tempScaleX
    objects[i].scaleY = tempScaleY
    objects[i].left = tempLeft
    objects[i].top = tempTop
    objects[i].setCoords()
  width = canvas.getWidth()
  height = canvas.getHeight()
  tempWidth = width * (1 / canvasScale)
  tempHeight = height * (1 / canvasScale)
  canvas.setWidth tempWidth
  canvas.setHeight tempHeight
  canvas.renderAll()
  canvasScale = 1
  return

    @canvas.on('after:render', (e)=>
        log 'rendered'
        object = @canvas.getActiveObject()
        if object
          @rotating(object)
        group = @canvas.getActiveGroup()
        if group
          objects = group._objects
          log objects
          for object in objects
            @rotating(object)
    )
    
            #if @isMoving
        #  @moving(object)
        #if @is_scaling
        #  @scaling(object)
        #if @is_rotating
        #  @rotating(object)
        #@isMoving  = false
        #@is_scaling = false
        #@is_rotating= false
    @canvas.on('object:selected', (e)=>
        object = e.target
    )
    @canvas.on('object:modified', (e)=>
        object = e.target
        log 'modified'
    )
    @canvas.on('object:moving', (e)=>
        object = e.target
        log 'moving'
        @isMoving  = true
    )
    @canvas.on('object:scaling', (e)=>
        object = e.target
        log 'scaling'
        @is_scaling = true
    )
    @canvas.on('object:rotating', (e)=>
        object = e.target
        log 'rotating'
        @is_rotating= true
    )
    @canvas.on('selection:cleared', (e)=>
      log 'unselect'
      log e.target
    )
  bind : (func)->
    object = @canvas.getActiveObject()
    if object
      func(object)
    group = @canvas.getActiveGroup()
    if group
      objects = group._objects
#      @canvas.deactivateAll().renderAll()
#      for object in objects
#        func(object, group)
#      objects = group._objects.map((object) ->
#        object.set "active", true
#      )
#      group = new fabric.Group(objects,
#        originX: "center"
#        originY: "center"
#      )
      @canvas._activeObject = null
      @canvas.setActiveGroup(group.setCoords()).renderAll()
    #@render()

  moving : ()->
    log 'moving'
    @bind (object)=>
      count = @match(object)
      if count!=null
        log object.top
        @objects[count].top_cm  = @transformTopY_px2cm(object.top)
        @objects[count].left_cm = @transformLeftX_px2cm(object.left)
  scaling : ()->
    log 'scaling'
    @bind (object, group)=>
      count = @match(object)
      if count!=null
        @objects[count].scaleX = object.scaleX / @scale
        @objects[count].scaleY = object.scaleY / @scale
        @objects[count].top_cm    = @transformTopY_px2cm(object.top)
        @objects[count].left_cm   = @transformLeftX_px2cm(object.left)
  rotating : ()->
    log 'rotating'
    @bind (object)=>
      count = @match(object)
      if count!=null
        @objects[count].angle    = object.angle
        @objects[count].top_cm   = @transformTopY_px2cm(object.top)
        @objects[count].left_cm  = @transformLeftX_px2cm(object.left)
###  $(@options.canvas).on 'drag', (e)=>
    if $(".is_visible .btn-primary").find('input').val()=='edit'
      return
    console.log(this, e)
    console.log(this, e.adx)
    if e.orientation=='vertical'
      if e.dx > 1
        @toTop(500)
      if e.dx < -1
        @toBottom(500)
    else
      if e.dy > 1
        @toLeft(500)
      if e.dy < -1
        @toRight(500)
  $(".is_visible input").change ->
    if $(".is_visible .btn-primary").find('input').val()=='move'
        #app.canvas.selection = false
        #app.render()
        $('canvas').css('cursor', 'move')
    if $(".is_visible .btn-primary").find('input').val()=='edit'
        #app.canvas.selection = true
        #app.render()
        $('canvas').css('cursor', 'pointer')
    is_visible = $(this).attr("id")
    buttons = $(this).closest(".btn-group").find(".btn")
    buttons.each (i, e) ->
      $(e).removeClass("btn-primary").removeClass("btn-default")
      if is_visible==$(e).find("input").attr("id")
        $(e).addClass "btn-primary"
      else
        $(e).addClass "btn-default"
###


# test cm px
app.scale = 1
x_cm = -125
log x_cm
x_px = app.transformLeftX_cm2px(x_cm)
log x_px

x_cm = app.transformLeftX_px2cm(x_px)
log x_cm

x_px = app.transformLeftX_cm2px(x_cm)
log x_px

###
  render : ->
    log 'render'
    @unselect()
    @canvas.clear()
    for o of @objects
      scaleX  = @objects[o].scaleX
      log 'scaleX:'+scaleX
      scaleY  = @objects[o].scaleY
      left_cm = @objects[o].left_cm
      top_cm  = @objects[o].top_cm
      angle   = @objects[o].angle
      tempScaleX = scaleX * @scale
      log 'tempScaleX:'+tempScaleX
      tempScaleY = scaleY * @scale
      tempLeft   = @transformLeftX_cm2px(left_cm)
      tempTop    = @transformTopY_cm2px(top_cm)
#      if tempLeft > @width 
#        continue
#      if tempTop > @height
#        continue
      object = @objects[o]['object']
      object.scaleX = tempScaleX
      object.scaleY = tempScaleY
      object.left   = tempLeft
      object.top    = tempTop
      if angle > 0
        object.angle  = angle
      object.originX = 'center'
      object.originY = 'center'
      object.setCoords()
      @canvas.add(object)
    if @scale==1 and @drawguideline
      fabric.drawGridLines(@canvas)
    @canvas.renderAll()
    @render_bg()
    @debug()
###

  match : (object)->
    count = 0
    for o in @objects
      if o['object'].id==object.id
        return count
      count += 1
    return null

  transformLeftX_cm2px : (cm)->
    # centerX(cm) => px
    return @canvas.getWidth()/2+(@centerX-cm)*@scale
    #return @centerX * @scale + @canvas.getWidth()  / 2 - cm * @scale
  transformTopY_cm2px : (cm)->
    return @canvas.getHeight()/2+(@centerY-cm)*@scale
    #return @centerY * @scale + @canvas.getHeight() / 2 - cm * @scale
  transformLeftX_px2cm : (px)->
    # left(px) => x(cm)
    #return (px+@centerX)/@scale-@canvas.getWidth()/2
    #return @canvas.getWidth() / 2 - (px + @centerX) * @scale
    return @centerX - (px - @canvas.getWidth() / 2) / @scale
  transformTopY_px2cm : (px)->
    #return (px+@centerY)/@scale-@canvas.getHeight()/2
    #return @canvas.getHeight() / 2 - (px + @centerY) * @scale 
    return @centerY - (px - @canvas.getHeight() / 2) / @scale

#      i = 0
#      while i < @count
#        if @side is 1
#          @__renderShelf ctx, x + i * w, y, w, h
#          if app.scale > 0.5
#            @__renderSide ctx, x + i * w, y, w, h
#        if @side is 2
#          @__renderShelf ctx, x + i * w, y, w, h
#          @__renderShelf ctx, x + i * w, y + h, w, h
#        i++

#  toTop :(y=100) ->
#    @unselect()
#    @centerY += y
#    @render()
#  toBottom : (y=100)->
#    @unselect()
#    @centerY -= y
#    @render()
#  toRight : (x=100)->
#    @unselect()
#    @centerX -= x
#    @render()
#  toLeft : (x=100)->
#    @unselect()
#    @centerX += x
#    @render()
#  load : ()->
#    objects = JSON.parse(localStorage.getItem('geojson'))
#    log objects
#    if objects
#      for object in objects
#        if object.id>@last_id
#          @last_id = object.id
#        if object.type=='shelf'
#          klass = fabric.Shelf
#        else if object.type=='curved_shelf'
#          klass = fabric.curvedShelf
#        else if object.type=='beacon'
#          klass = fabric.Beacon
#        else
#          continue
#        shape = new klass(
#          id: object.id
#          count: object.count
#          side: object.side
#          top: app.transformLeftX_cm2px(object.top_cm)
#          left: app.transformTopY_cm2px(object.left_cm)
#          fill: "#CFE2F3"
#          stroke: "#000000"
#          angle: object.angle
#        )
#        @add(shape)
#    canvas = JSON.parse(localStorage.getItem('canvas'))
#    if canvas
##      log canvas
#      @scale   = canvas.scale
#      $('.zoom').html((@scale*100).toFixed(0)+'%')
#      @centerX = canvas.centerX
#      @centerY = canvas.centerY
#    @render()


#    object.on(
#      modified: =>
#        @moving(object)
#        @scaling(object)
#        @rotating(object)
#      moving: =>
#        @moving(object)
#      scaling: =>
#        @scaling(object)
#      rotating: =>
#        @rotating(object)
#    )


#    canvas = document.createElement('canvas')
#    canvas = new fabric.Canvas(canvas);
#    canvas.setWidth @options.max_width
#    canvas.setHeight @options.max_height
#    tmp_canvas = @canvas
#    tmp_scale = @scale
#    @canvas = canvas
#    @scale = 1

#    @canvas = tmp_canvas
#    @scale = tmp_scale

    return
    a = document.createElement('a')
    a.download = 'sample.geojson'
    a.type = 'application/json'
    blob = new Blob([geojson], {"type": "application/json"})
    a.href = (window.URL || webkitURL).createObjectURL(blob)
    a.click()


オブジェクトのプロパティ
プロパティからパネルを作成

パネルの変更をオブジェクトに反映
GeoJSONに反映

プロパティのグルーピング


groups :
    property:
        row: 2
        count: 6
    shelfs: []



canvas:
    width: 1162
    height: 713
    centerX: 1014
    centerY: -357
    bgscale: 4.425




      w = @__const_width() * @count
      h = @__const_height() * @side
      center = @getCenterPoint()
#      log center
      log center.x
      x = -w / 2 + center.x
      y = -h / 2 + center.y
      x = app.transformLeftX_px2cm(x) / 100
      y = app.transformTopY_px2cm(y) / 100
      # 中心点からの距離の比を出す
#      map_center =
#        lat : 35.155080
#        lon : 136.963791
#      map_edge =
#        lat : 35.155049
#        lon : 136.963791
      map_center =
        lat : 4184975.9183342634
        lon : 15246739.471236346
      map_edge =
        lat : 4184971.697544111
        lon : 15246739.471236346
      half_distance = map_center.lat - map_edge.lat
      # 地図の幅半分 / 5000
      cm_ratio = half_distance / 5000
      x = map_center.lon + x * cm_ratio
      y = map_center.lat + y * cm_ratio
      h = h * cm_ratio
      w = w * cm_ratio
      data =
        "type": "Feature"
        "geometry":
          "type": "Polygon",
          "coordinates": [
            [ [x, y], [x + w, y], [x + w, y - h], [x, y - h], [x, y]]
          ]
        "properties":
          "type"  : @type
          "id"    : @id
          "count"    : @count
          "side"    : @side
          "angle" : @angle
      return data

#        w = object.properties.eachWidth * object.properties.count
#        h = object.properties.eachHeight * object.properties.side
#        x = object.geometry.coordinates[0][0][0]
#        y = object.geometry.coordinates[0][0][1]
#        top = y * 100 + h / 2
#        left = x * 100 + w / 2
#        top = @transformTopY_cm2px(top)
#        left = @transformLeftX_cm2px(left)

#  getGeoJSON : ->
#    @unselect()
#    @render()
#    geojson = @translateGeoJSON()
#    localStorage.setItem('geojson', JSON.stringify(geojson))
#    log geojson
#    $(window).off 'beforeunload'
#    location.href = 'map2.html'


#  gmap = new google.maps.Map(document.getElementById("gmap"),
#    disableDefaultUI: true
#    keyboardShortcuts: false
#    draggable: false
#    disableDoubleClickZoom: true
#    scrollwheel: false
#    streetViewControl: false
#  )
  # Set the stroke width, and fill color for each polygon
  featureStyle = {
    fillColor: 'orange',
    strokeWeight: 1
  }
  map.data.setStyle(featureStyle)
  features = map.data.addGeoJson(haika.createGeoJson())
  # make sure the view doesn't go beyond the 22 zoom levels of Google Maps
#  view = new ol.View2D(maxZoom: 21)

#  center = ol.proj.transform([ haika.options.lon, haika.options.lat ], "EPSG:4326", "EPSG:3857")
#  view = new ol.View2D(
#    center: center
#    zoom: 2
#    maxZoom: 21
##    maxResolution: 20
#  )
#  view.on "change:center", ->
#    center = ol.proj.transform(view.getCenter(), "EPSG:3857", "EPSG:4326")
#    gmap.setCenter new google.maps.LatLng(center[1], center[0])
#  view.on "change:resolution", ->
#    gmap.setZoom view.getZoom()
#
#  olMapDiv = document.getElementById("olmap")
#  window.map = new ol.Map(
#    target: "map"
#    ol3Logo: false
#    layers: []
##    layers: [new ol.layer.Tile(source: new ol.source.OSM())]
#    interactions: ol.interaction.defaults(
#        altShiftDragRotate: false
#        dragPan: false
#        rotate: false
#    ).extend([new ol.interaction.DragPan(kinetic: null)])
#    target: olMapDiv
#    view: view
#  )
#  view.setCenter(center)
#  view.setZoom(20)
#  olMapDiv.parentNode.removeChild olMapDiv
#  gmap.controls[google.maps.ControlPosition.TOP_LEFT].push olMapDiv
#
#  map.on 'moveend', (e)->
#    center = map.getView().getCenter()
#    new_center = ol.proj.transform(center, "EPSG:3857", "EPSG:4326")
#    $('#canvas_lon').val(new_center[0])
#    haika.options.lon = new_center[0]
#    $('#canvas_lat').val(new_center[1])
#    haika.options.lat = new_center[1]
#    haika.save()

#  featureOverlay = new ol.FeatureOverlay({
#    style: new ol.style.Style({
#      fill: new ol.style.Fill({
#        color: 'rgba(255, 255, 255, 0.2)'
#      }),
#      stroke: new ol.style.Stroke({
#        color: '#ffcc33',
#        width: 2
#      }),
#      image: new ol.style.Circle({
#        radius: 7,
#        stroke: new ol.style.Stroke({
#          color: '#ffffff',
#          width: 2
#        }),
#        fill: new ol.style.Fill({
#          color: '#0077FF'
#        })
#      })
#    })
#  })
#  featureOverlay.addFeature(new ol.Feature(new ol.geom.Point(center)))
#
#  featureOverlay.setMap(map);
#  draw = new ol.interaction.Draw({features: featureOverlay.getFeatures(), type: "Point"})
#  modify = new ol.interaction.Modify({
#    features: featureOverlay.getFeatures(),
#    deleteCondition: (event) =>
#      return ol.events.condition.shiftKeyOnly(event) &&
#        ol.events.condition.singleClick(event);
#  })
  #map.addInteraction(modify);
  #map.addInteraction(new ol.interaction.DragRotateAndZoom())
  #map.addInteraction(draw);
#  map.addControl(new ol.control.ZoomSlider())
#  map.addControl(new ol.control.ScaleLine())

#$('#map_search').submit ->
#  url = 'http://nominatim.openstreetmap.org/search'
#  $.ajax
#    url: url
#    type: "GET"
#    data:
#      q: $('#map_query').val()
#      format: "json"
#    dataType: "jsonp"
#    jsonp: "json_callback"
#    error: ()->
#    success: (data)=>
#      log data
#      if data.length>0
#        haika.options.lon = parseFloat(data[0].lon)
#        haika.options.lat = parseFloat(data[0].lat)
#        haika.save()
#        $('#canvas_lon').val haika.options.lon
#        $('#canvas_lat').val haika.options.lat
#        center = ol.proj.transform([ haika.options.lon, haika.options.lat ], "EPSG:4326", "EPSG:3857")
#        view = map.getView()
#        view.setCenter(center)
#        view.setZoom(20)
#      else
#        alert '見つかりませんでした。'
#  return false;

#  $(".geojson").click ->
#    haika.getGeoJSON()

  $('#canvas_render').click ->
    haika.render()
<!--
      <div class="row">
        <div class="col-md-2" style="text-align:center;width: 120px;">
          <input type="button" class="totop btn btn-default" value="↑" /><br />
          <input type="button" class="toleft btn btn-default" value="←" />
          <input type="button" class="toright btn btn-default" value="→" /><br />
          <input type="button" class="tobottom btn btn-default" value="↓" />
        </div>
        <div class="col-md-10">

          <div class="btn-group btn-group-sm is_visible" data-toggle="buttons">
            <label class="btn btn-sm btn-default">
              <input type="radio" name="display" id="true" value="move">移動
            </label>
            <label class="btn btn-sm btn-primary">
              <input type="radio" name="display" id="false" value="edit">編集
            </label>
          </div>
-->
          <div class="btn-group">
            <button type="button" class="btn btn-danger">オブジェクトを追加</button>
            <button type="button" class="btn btn-danger dropdown-toggle" data-toggle="dropdown">
                <span class="caret"></span>
                <span class="sr-only">Toggle Dropdown</span>
            </button>
            <ul class="dropdown-menu" role="menu">
                <li role="presentation" class="dropdown-header">書架</li>
                <li><a href="#">一般</a></li>
                <li><a href="#">文庫・新書用</a></li>
                <li><a href="#">大型本</a></li>
                <li><a href="#">CD/DVD</a></li>
                <li><a href="#">新聞</a></li>
                <li><a href="#">雑誌</a></li>
                <li class="divider"></li>
                <li role="presentation" class="dropdown-header">特殊な書架</li>
                <li><a href="#">曲面</a></li>
                <li class="divider"></li>
                <li role="presentation" class="dropdown-header">インドアロケーション</li>
                <li><a href="#">BLEビーコン</a></li>
            </ul>
          </div>

          <div style="display: none;">

          <label for="type">type:
              <select id="type" class="form-control">
                  <option value="shelf">Shelf</option>
                  <option value="curved_shelf">curvedShelf</option>
                  <option value="mini_shelf">miniShelf</option>
                  <option value="beacon">Beacon</option>
              </select>
          </label>
          <label for="count">count:
              <input type="text" id="count" class="form-control" value="3" style="width: 60px;" />
          </label>
          <label for="side">side:
              <select id="side" class="form-control">
                  <option value="1">one</option>
                  <option value="2">both</option>
              </select>
          </label>
          <label for="angle">angle:
              <select id="angle" class="form-control">
                  <option value="0">0</option>
                  <option value="90">90</option>
                  <option value="180">180</option>
                  <option value="270">270</option>
              </select>
          </label>
          <input type="button" class="add btn btn-default" value="add" />
          </div>


if @options.bgurl
  @loadBgFromUrl(@options.bgurl)

  # 背景画像をファイルからロード
  loadBgFromFile : (file) ->
    reader = new FileReader()
    reader.onload = (e) =>
#      log e.currentTarget.result
      img = new Image()
      img.src = e.currentTarget.result
      @bgimg = new fabric.Image(img)
      @setBg()
      @saveDelay()
    reader.readAsDataURL file

  if haika.isLocal()
    haika.loadBgFromFile files[0]
  else
  
        bgimg_data: @bgimg_data
      @bgimg_data = canvas.bgimg_data





#            log [x,y]
#            coordinate = ol.proj.transform([x,y], "EPSG:3857", "EPSG:4326")



<!--
    <script type="text/javascript" src="vendor/sprintf.js"></script>
    <script type="text/javascript" src="bower_components/proj4/dist/proj4.js"></script>
    <script type="text/javascript" src="bower_components/json-editor/dist/jsoneditor.min.js"></script>
    <script type="text/javascript" src="bower_components/jquery-mousewheel/jquery.mousewheel.min.js"></script>
    <script type="text/javascript" src="bower_components/dragdealer/dragdealer.min.js"></script>
    <script type="text/javascript" src="bower_components/Javascript-Undo-Manager/js/undomanager.js"></script>
    <script type="text/javascript" src="vendor/mousetrap.min.js"></script>
    <script type="text/javascript" src="bower_components/jquery.finger/dist/jquery.finger.min.js"></script>
    <script type="text/javascript" src="vendor/bootstrap-colorselector-0.2.0/js/bootstrap-colorselector.js"></script>
    <script type="text/javascript" src="bower_components/bootstrap-slider/bootstrap-slider.js"></script>
    <script src="vendor/clipper.js"></script>
    <script type="text/javascript" src="vendor/fabric.js"></script>
    <script type="text/javascript" src="vendor/aligning_guidelines.js"></script>
-->
<!--
    <script type="text/javascript" src="vendor/centering_guidelines.js"></script>
    <script type="text/javascript" src="vendor/fabric.min.js"></script>
    <script type="text/javascript" src="vendor/loadsvg.js"></script>
-->
<!--
    <script type="text/javascript" src="js/fabric_obiect/shelf.js"></script>
    <script type="text/javascript" src="js/fabric_obiect/curvedShelf.js"></script>
    <script type="text/javascript" src="js/fabric_obiect/beacon.js"></script>
    <script type="text/javascript" src="js/fabric_obiect/wall.js"></script>
    <script type="text/javascript" src="js/fabric_obiect/floor.js"></script>
    <script type="text/javascript" src="js/fabric_obiect/grid.js"></script>
    <script type="text/javascript" src="js/haika.js"></script>
    <script type="text/javascript" src="js/haika_io_v1.js"></script>
    <script type="text/javascript" src="js/init.js"></script>
    <script type="text/javascript" src="js/editor.js"></script>
    <script src="vendor/ol.js"></script>
    <script src="js/map_setting.js"></script>
-->


    connect:
      server:
        options:
          hostname: "localhost"
          port: 9000
          keepalive: true
          open: true
          middleware: (connect, options) ->
            [proxySnippet]

        proxies: [
          context: "/"
          host: "app.haika.io"
          port: 443
          https: true
          xforward: true
          headers:
            'Strict-Transport-Security' : 'max-age=0'
        ]


  grunt.registerTask "server", (target) ->
    grunt.task.run [
      "configureProxies:server"
      'connect:server'
#      "open"
      "esteWatch"
    ]


    save_license:
      dist:
        src: jsfiles,
        dest: 'licenses.md'
